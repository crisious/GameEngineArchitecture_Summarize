# 1.1 게임 팀 구성

### 1.1.1 엔지니어

엔지니어는 게임 만드는 소프트웨어와 툴을 디자인 하고 구현한다.

고참 엔지니어는 때때로 테크니컬 리더 역할을 맡아야 한다. \(코드 작성 외에 일정 관리, 기술문제 결정에 참여\)

Technical Director \(TD\) 를 두는 회사도 있다.

### 1.1.2 아티스트

시각/청각 콘텐츠를 만드는 사람.

* 컨셉 아티스트 : 게임의 완성된 비전을 팀 전체에 그림으로 제시한다.
* 3D 모델러 : 게임 월드의 3D 기하 형상\(geometry\)을 만든다. \(foreground:케릭터, background:배경\)
* 텍스쳐 아티스트 : 3D 입혀질 2D 이미지를 그린다.
* 광원 아티스트 : 정적/동적 광원 을 설정한다. \(예술적 효과 및 감정적 연출\)
* 애니메이터 : 케릭터 및 물체 동작을 부여한다.
* 모션 캡쳐 배우 : 애니메이터가 사용할 대강의 움직임 데이터를 만든다.
* 사운드 디자이너 : 효과음/배경음악 등을 제작한다.
* 성우 : 케릭터 및 소리 효과 등을 제작한다.

대체로 고참 아티스트가 팀 리더 역할을 맡는다.

### 1.1.3 기획자 \(게임 디자이너\)

기획자는 사용자의 게임상 경험, 게임 플레이를 설계한다.

어떤 팀은 작가를 고용하기도 한다.

고참 기획자가 관리자 역할을 맡기도 한다. \(전반적인 게임 설계/일정 관리/기획 일관성 책임\)

1.1.4 프로듀서

일정 관리/인력 관리를 맡거나 상급 기획 업무를 맡기도 한다.

작은 스튜디오의 경우 없는 경우도 있다.

### 1.1.5 지원 부서 \(스텝\)

경영관리 / 마케팅 / IT 기술지원 등이 해당

### 1.1.6 퍼블리셔

대부분 개발 스튜디오는 특정 퍼블리셔와 독점적인 관계를 맺지는 않는다.

# 1.2 게임이란

게임이론 : 명확히 정의된 규칙 아래 다양한 에이전트들이 최선의 이익을 얻기 위해 전략적, 전술적 행동을 하는 것.

사용자에게 점진적으로 난이도가 증가하는 도전 과제를 제시하고, 사용자가 궁극적으로 그 과정을 학습하고 숙달하는

상호적인 경험을 제공하는 행위

### 1.2.1 덜 엄격한 실시간 시뮬레이션으로서의 게임

soft real-time interactive agent-based computer simulations

행위자 기반의 시뮬레이션 : 각각 서로 다른 '행위자'들 간의 상호작용

모든 실시간 기반 시스템은 시간 제약\(deadline\) 을 품고 있다.

덜 엄격한 실시간 시스템 : 시간 제약을 지키지 못해도 치명적인 결과가 발생하지 않는다는 것.

수학적 모델 - 분석적 모델 : 변수 값만 있으면 언제든 결과를 계산할 수 있는 모델\(예 : 중력가속도 등\)

수학적 모델 - 수치적 모델 : 미래 시각을 현재 시각을 기준으로 계산해서 스스로를 갱신\(예:컨트롤러 입력 계산 등\)

# 1.3 게임 엔진이란?

'게임 엔진' 용어는 '둠' 등의 FPS 게임에서 유래

핵심적인 소프트웨어와 사용자 게임 관련 요소들을 구분되게 설계

모드 : 게임 개발사가 무료 배포하는 도구 이용해 기존 게임을 수정해서 새 게임을 만드는 개인/소스튜디오

오늘날 게임 엔진을 사서 개발을 시작하는 경우가 흔하다.

게임 엔진과 게임의 경계를 나누기가 쉽지 않다.

게임 소프트웨어가 게임 엔진인지 아닌지를 구분할 때는 그 소프트웨어가 데이터 주도\(data-driven\) 적으로 설계 되었는지 보는 것이 일반적이다.

![](/assets/1_1.PNG)

대부분 게임 엔진은 특정 게임과 플랫폼에 맞게 만들어지고 최적화된다.

일반적으로 게임 엔진이나 미들웨어 범용성이 커질수록 특정 플랫폼이나 게임에 대한 최저고하는 떨어진다.

하드웨어 성능이 향상되고 효율적인 알고리즘과 자료구조가 개발되면서 그래픽 엔진들 간 차이가 줄어들고 있다.

범용성과 최적화 간의 균형과 선택은 여전히 중요한 문제다.

# 1.4 장르별 게임 엔진

### 1.4.1 1인칭 시점 슈터\(FPS\)

1인칭 시점은 사용자를 설득력 있고 굉장히 사실적인 환경에 몰입시켜야 하는 1인칭 시점 게임의 특성에서 기인한다.

* 광활한 3D 가상 세계의 효율적 렌더링
* 즉각적인 카메라 조작/조준
* 매우 사실적인 캐릭터
* 다양한 종류의 소형화기 구현
* 케릭터 애니메이션과 충돌 구현
* 사실적인 NPC와 인공지능
* 멀티 플레이 지원

FPS 렌더링 기술은 거의 게임 플레이의 배경에 최적화 되고 조정된다.

### 1.4.2 플랫포머와 다른 3인칭 시점 게임

플랫포머 : 여러 발판\(platform\) 사이를 뛰어다니는 일이 주된 게임 플레이인 3인칭 시점 게임

FPS와 유사하지만 메인 케릭터의 능력이나 이동 방식에 더 강조를 두는 차이점이 있다.

메인 케릭터는 딱히 사실적이 아닌 경우가 많다.

* 움직이는 발판, 사다리, 밧줄, 창살 등 흥미로운 이동 방식
* 퍼즐이 가득한 배경
* 3인칭 시점 카메라
* 절대 배경이나 물제에 가리거나 뚫고 들어가지 않게 하는 카메라 충돌

### 1.4.3 격투 게임

* 풍부한 격투 애니메이션
* 정확한 타격 감지
* 복잡한 입력을 처리할 수 있는 시스템
* 군중과 대체로 정적인 배경
* 물리 기반 의복/머리카락 시뮬레이션

### 1.4.4 레이싱 게임

시뮬레이션 레이싱 : 사실성을 강조해서 드라이빙 경험을 주는것이 목적

아케이드 레이싱 : 재미를 주는데 주 목적

* 먼 곳의 배경을 그리기 위한 최적화 기법
* 단순한 2차원적 구획으로 나누어 표시
* 3차원 시점/1차원 시점 제공
* 카메라가 배경과 안부딪치게 설정

### 1.4.5 실시간 전략 게임 \(RTS\)

넓은 필드에서 각자가 가진 전투 유닛들을 전략적으로 조종해 상대방을 제압

카메라 각도를 대체적으로 고정 시킨다. 그래서 최적화 할 여지가 많다.

* 한 번에 많은 수의 유닛이 화면에 나와도 문제 없게 한다.
* 배경 지형은 높이 필드\(height field\) 통해 구현하는 경우가 많다.
* 병력 조종 기능/건물 빌드 기능이 있다.
* 매뉴/툴바 통해서 명령/장비/유닛타입/빌딩타입 등을 표시

### 1.4.6 대규모 다중 사용자 멀티플레이어 온라인 게임\(MMOG\)

넓으면서 지속적인 가상세계에서 게임을 하는 것

그래픽은 여타 게임들보다 다소 떨어진다. 큰 게임 월드를 한꺼번해 처리해야 할 게이머 수 때문.

### 1.4.7 기타 장르

* 스포츠 게임
* 롤 플레잉 게임
* 갓 게임\(파퓰러스/블랙&화이트\)
* 건설 시뮬레이션\(심시티\) / 소셜 시뮬레이션\(심즈\)
* 퍼즐 게임\(테트리스\)
* 고전 게임\(체스/카드\)
* 웹 게임\(pogo.com\)
* 기타 등등

게임 장르마다 기술적 요구사항이 다르지만 여전히 공통적인 부분이 많다.

# 1.5 현존하는 게임 엔진

### 1.5.1 퀘이크 계열 엔진

* 퀘이크3 \(ID소프트\)
* Sin\(Retual\)

* F.A.K.K.2 \(Retual\)

* Medal of Honor : Allied assult

* Medal of Honor : Pacific Assult

직접 소스코드를 다운로드 받아서 빌드해 보고 디버깅 해보면서 게임 엔진이 정말 어떻게 동작하는지 배울 수 있다.

### 1.5.2 언리얼 엔진

다양한 기능과 일관적이고 쓰기 편한 툴

강력한 프로토타입 툴이자 상용 게임 개발 도구.

소스코드는 현재 공개 되어 있다. 가격에 대해서도 과거에 비해 낮아진 편.

언리얼 엔진을 다루는 웹사이트가 다수 존재 \(예:www.beyondureal.com\)

### 1.5.3 하프라이프 소스 엔진

언리얼 엔진에 견줄만한 그래픽 렌더링 성능

하프라이프/팀 포트리스/오랜지박스/포탈 등을 개발하는데 사용됨

### 1.5.4 마이크로소프트 XNA 게임 스튜디오

C\# 기반으로 소스코드 부터 리소스 까지 직접 관리

PC 와 XBOX 360 게임 까지 개발 가능

현재는 서비스 종료된 상태.

### 1.5.5 기타 상용 엔진

C4 엔진 \(에릭 렝겔 2001\) 등

### 1.5.6 비공개 자체 개발 엔진

세이지 엔진 \(EA\), 언차티드 등

기존 상용 게임 엔진들도 초기에는 자체 개발 엔진이였음.

### 1.5.7. 오픈소스 엔진

소스코드가 완전히 공개되 누구나 코드를 만드는 데 기여할 수 있는 비교적 개방된 개발 방법

Gnu Public License, LGPL 에 따라 배포

Ogre 엔진 : 3D 렌더링 기능들을 거의 대부분 갖추고 있는 장점

Panda3D : 파이썬 기반, 3D 프로토타입  위한 쉽고 빠른 개발 목적

Yake : Ogre 기반, 완전 기능 갗춘 최신 게임 엔진

Crystal , Irrlicnt 등

# 1.6 런타임 게임 아키텍쳐

게임 엔진도 계층적으로 구성된다. \(선형 의존\)\(하위 계층이 상위 계층에 의존할 때\)

![](/assets/arch.jpg)

### 1.6.1 목표 하드웨어

게임이 동작할 컴퓨터/콘솔 시스템

### 1.6.2.  디바이스 드라이버

하드웨어, 다른 상위 계층 소프트웨어 에서 불필요한 하드웨어 요인들을 신경쓰지 않음.

### 1.6.3. 운영체제

MS 윈도우는 '선점혈 멀티태스킹' 이용한 시간 기반 기법

다른 프로그램의 존재를 염두해 두어야 한다.

콘솔 환경에서는 게임이 하드웨어를 완전 독점 가능. \(지금은 라이브 SNS 등으로 작업 전환 가능\)

### 1.6.4 서드파티 SDK 와 미들웨어

#### 1.6.4.1 자료구조와 알고리즘

* STL\(C++ 표준 템플릿 라이브러리\)
* STLPort \(좀더 다양한 플렛폼을 위한 STL\)
* STL 스타일로 설례된 강역 자료구조와 알고리즘 라이브러리
* Boost \(STL 스타일 자료구조/알고리즘 라이브러리\)
* Loki \(Generic Programming Template Library\)

#### 1.6.4.2 그래픽스

* Glide : Voodoo 용 3D 그래픽 SDK
* OpenGL : 멀티 플렛폼 기반 그래픽스 SDK
* DirectX : 마이크로소프트 개발 SDK, OpenGL 과 양대 산맥
* libgcm : 소니 플레이스테이션3 RSX 그래픽 하드웨어용 SDK
* Edge : 너티독 & 소니 개발 한 플레이스테이션3용 고성능 렌더링/애니메이션 엔진

#### 1.6.4.3 충돌과 물리

* Havok : 고성능 물리, 충돌 엔진
* PhysX : NVidia 개발한 고성능 물리/충돌 엔진
* Open Dynamics Engine\(ODE\) : 오픈소스 물리/충돌 엔진

#### 1.6.4.4 케릭터 애니메이션

* Granny : RAD Games 개발한 SDK. 모델링 툴에 대한 export 도구 및 Runtime Library / Runtime Animation System 제공
* Havok animation : 물리와 애니메이션 간 보완을 위해 만든 SDK
* Edge : 너티 독 ICE 팀과 소니 개발 부서 합작해 만든 PS3용 애니메이션 엔진 및 Geometry 처리 엔진

#### 1.6.4.5 인공지능

* Kynapse : 길찾기, 정/동적 충돌 회피, 공간 내 취약점 감지 등의 기본적 인공지능 개발 도구 제공\(Gameware Navigation 변경\)

#### 1.6.4.6 생체 역학적 케릭터 모델

* 엔트로핀과 유포리아\(Endorphin and Euphoria\) : 인체 움직임을 생체 역학적 모델로 분석해 애니메이션 생성

### 1.6.5 플렛폼 독립적 계층

하드웨어, 드라이버, OS, 기타 외부 SDK 등의 바로 위에서 동작

엔진의 다른 부분들이 하드웨어를 신경쓰지 않게 하는 역할을 맡는다.

서로 다른 플랫폼 에서도 일관성 있는 동작을 보장한다.

### 1.6.6 코어 시스템

* Assertion : 프로그램 에러 검출 및 코드 작성 조건들을 점검하는 코드, 최종 버전에서는 보통 제거됨.
* 메모리 관리 : 메모리 할동/해제의 효율성, 메모리 단편화 방지 위한 젼용 메모리 시스템 구현
* 수학\(math\) 라이브러리 : 벡터, 행렬, 사원수, 삼각함수, 선, 빛, 구, 절두체, 스플라인, 수치 적분, 방정식 등
* 독자적 자료 구조와 알고리즘 : 기본적인 자료구조\(연결 리스트, 동적 배열, 이진 트리, 해시 맵\)와 알고리즘 \(검색, 정렬 등\)을 처리하기 위한 도구가 필요함.

### 1.6.7 자원 관리자

집중되고 일관성 있는 방식 : 언리얼의 패키지, 오우거 엔진 ResourceManager

산발적인 방식 : 직접 파일이나 디스크에서 원하는 자원을 가져와야 하는 경우

### 1.6.8 렌더링 엔진

#### 1.6.8.1 로우레벨 렌더링

Geometry Primitive 를 가능한 빠르게 그리면서 다양한 방식을 지원하는 데 중점

화면의 가시성 등 추상적인 문제에는 관여하지 않는다.

* 그래픽 디바이스 인터페이스 : 그래픽 SDK 사용 인터페이스
* 기타 렌더러 구성 요소 : geometry primitive 처리, viewport, materials, dynamic light system, shading, etc...

#### 1.6.8.2 장면 그래프와 추려내기 최적화 \(SceneGraph & Culling optimization\)

frustum culling \(절두체 추려내기\) : 작은 월드에서 사용

PVS\(potentiaully visible set\) : 보일 가능성이 있는 집합

예\) 오거엔진 plug-and-play scene graph architecture

#### 1.6.8.3 시각 효과 \(Visual Effects\)

* 파티클 시스템
* 데칼 시스템
* 조명 매핑과 환경 매핑
* 동적 그림자
* 풀 스크린 후처리 효과

  풀 스크린 후처리 효과의 예시 : HDR, Bloom, Full Screen Anti-aliasing, color correction, color shift, bleach bypass, saturation, de-saturation

#### 1.6.8.4 전단부 \(Front End\) {#front-end}

* 게임 HUD \(Heads-Up Display\)
* 게임 메뉴, 콘솔, 기타 개발 툴 \(최종 배포본 에는 포함되지 않을 수 있음\)
* 캐릭터 인벤토리 등의 그래픽 유저 인터페이스 \(GUI\)
* 풀 모션 비디오\(FMV\)

* 인게임 시네마틱\(In-Game Cinematic\)

* 래퍼/유인 모드

### 1.6.9 프로파일링과 디버깅 툴

녹화/재생 기능, 메모리&성능 통계, 게임 메뉴 혹은 콘솔

Intel VTune, IBM Quantify & Purify, Compuware Bounds Checker

자체 프로파일링 & 디버깅 기능 구현시 포함되는 기능들

* 코드를 수동으로 소모시간 측정 해주는 시스템
* 실시간 프로파일링 수치 표시 기능
* 성능 값을 export 하는 기능 \(엑셀, 텍스트 등\)
* 게임 엔진, 각 하부 시스템 사용 메모리 측정
* 메모리 사용량, 최고 사용량, 메모리 누수 통계 등을 게임이 종료 혹은 플레이 중에 export 하는 기능

* 디버그 메시지를 코드 또는 출력 필요한 항복마다 켜고 끄는 기능을 가진 툴. 자세한 정보 조정 가능

* 게임 플레이 녹화/재생 하는 기능

### 1.6.10 충돌과 물리

강체 역학 \(rigid body\)

강체의 움직임\(운동학\), 힘과 회전력\(역학\)

충돌하게 되면 물리 로직, 제약 만족 로직 \(constraint satifaction\) 의 일부로 처리

대체로 외부 SDK 를 사용한다. \(예 : Havok, PhysX\)

오픈소스 물리/충돌 엔진 : Open Dynamic Engine \(ODE\), I-Collide, V-Collide, RAPID

### 1.6.11 애니메이션

* 스프라이트/텍스쳐 애니메이션
* 강체 계층\(rigid doby hierachy\) 애니메이션
* 뼈대\(skeletal\) 애니메이션
* 정점 \(vertex\) 애니메이션
* 모트 타겟\(morph target\)

![](/assets/1_25.PNG)

뼈대 메쉬 렌더링이 렌더러 와 에니메이션 시스템 사시에 걸쳐있다. 인터페이스는 분명하게 정의되어 있다.

스키닝 : 캐릭터 모든 관절을 특정 포즈로 위치-&gt;렌더링 엔진 전달-&gt;각 정점대해 행렬에 의한 변환-&gt;최종 정점 위치 계산

래그 돌\(Rag doll\) : 애니메이션 시스템이 물리 시스템에 의해 움직임. 강체 시스템으로 취급해서 위치와 방향 결정 후, 렌더링 엔진에 필요한 행렬을 계산

### 1.6.12 휴먼 인터페이스 장치\(HID\)

* 키보드/마우스
* 조이패드
* 기타 특수 컨트롤러 \(운전대, 낚시대, 댄싱, 위모트 등\)

  게임 종속적 인터페이스 + 물리 장치 I/O

  플랫폼 마다 다른 하드웨어 정보를 상위 게임 컨트롤에서 분리시키는 것이 주요 고려 사항인 경우

  스틱 반응에 대한 데드존, 버튼 눌림 입력을 다시 원래대로 돌리기, 버튼 업/다운 감지, 가속도계 입력 해석

  코드\(여러 버튼이 한꺼번에 눌리는 것\), 연타, 제스처 감지하는 경우도 있다.

### 1.6.13 오디오

다른 부분에 비해 덜 주목 받는다.

오디오 엔진의 정교함은 게임 엔진에 따라 많이 다르다.

완성된 오디오 엔진을 사용해서 개발하더라도 최종 게임에 들어갈 품질 높은 오디오를 완성하기 위해 많은 개발 비용과 끊임없는 노력 필요

### 1.6.14 온라인멀티플레이서 와 네트워킹

* 단일 스크린 멀티 
* 분할 화면 멀티플레이어

  게임 월드,게임 객체, 렌더러, HUD, 모두 영향 받는다.

  싱글플레이어 게임으로 바꾸는 것은 의외로 간단하다.

  퀘이크 엔진 '서버 위에 클라이언트 얹혀있는 구조' \(프로그램 하나가 동시에 클라이언트 와 서버 역할을 맡는다.\)

### 1.6.15 게임플레이 기반 시스템

#### 1.6.15.1 게임 월드와 객체 모델

게임 월드에 속하는 여러 구성물들은 대개 객체지향적인 방법으로 모델화하고, 이를 위해 객체지향적 프로그래밍 언어를 사용하는 것이 보통이다.

* 정적인 배경, 빌딩, 길, 지형\(보통 특별 취급한다\) 등
* 동적인 단단한 물체들. \(바위, 음료수, 캔, 의자 등\)
* 플레이어 캐릭터 \(PC\)
* NPC\(non-player characters\)
* 무기
* 발사체\(projectile\)
* 탈것\(vehicles\)
* 빛\(런타임에 실시간 조명에 사용되기도 하고 오프라인에서 정적 조명 계산에만 사용되기도 한다.\)
* 카메라
* 기타 여러 가지

  게임 엔진에서 소프트웨어 객체 모델이 갖는 문제

* 엔진 디자인이 객체지향적인가?

* 어떤 개발 언어를 사용할 것인가? C, C++, Java, OCaml?

* 클래스 구조는 어떤 형태를 띨 것인가? 거대한 한 개의 수직적인 구조인가 아니면 서로 연관성이 적은 느슨한 수평적 구조인가?

* 템플릿과 정책 기반\( policy-based\) 디자인을 사용할 것인가? 아니면 전통적인 다형성을 사용할 것인가?

* 객체 접근시 어떤 방식을 사용할 것인가? 포인터, 스마트 포인터, 핸들 중 어느것을 사용할 것인가?

* 서로 다른 객체를 어떻게 고유하게 분별할 것인가?물리적 주소, 이름을 사용할 것인가 아니면 GUID를 사용할 것인가?
* 객체 수명은 어떻게 관리할 것인가?
* 시간이 흐름에 따라 각 객체의 상태는 어떻게 시뮬레이션할 것인가?

#### 1.6.15.2 이벤트 시스템

흔히 쓰이는 객체 간 통신 방법

보내는 쪽이 정보를 실은 작은 구조체를 만든다. '이벤트 핸들러' 함수 호룰하고 이벤트 큐에 보관하고 나중에 처리하게 구현할 수도 있다.

#### 1.6.15.3 스크립트 시스템

게임 규칙, 컨텐츠 빠른 개발을 위해 사용

수정하고 빠른 재시작 할 수 있다. \(컴파일 링크 시간을 줄인다.\)

#### 1.6.15.4 인공지능 시스템

인공지능 기반 계층에 쓸모 있는 기능

* AI 캐릭터가 지형지물과 충돌할 염려 없이 마음대로 돌아다닐 수 있는 지역을 경로 노드 혹은 이동 볼륨으로 연결 지정
* 돌아다닐 영역 경계에 대한 충돌 정보를 간단하게 정의하는 기능
* 영역 진입하고 진출하는 입구 정보 및 적들이 캐릭터를 보거나 공격 가능한 지역 지정
* A\* 알고리즘을 기반으로 한 길 찾기 엔진
* 충돌 시스템과 게임 월드 모델을 활용해 시선 추적 이나 기타 인지 기능에 사용하는 기능
* 모든 연관 단위들\(아군, 적은, 장애물 등\) 위치와 동적 충돌 회피 등 AI 전용 월드 모델

### 1.6.16 게임 특화 하부 시스템 \(Game Specific sub systems\)

게임 엔진과 게임을 구분할 만한 기반 계층

어떤 게임을 개발하느냐에 따라 종류나 특화되는 모습이 보인다.

## 1.7 툴\(도구\)과 자원 파이프라인

![](/assets/1_31.PNG)

게임 자원, 설정 파일, 스크립트 등이 DCC 툴부터 게임 엔진에 까지 데이터 흐름으로 연결되어 있다.

### 1.7.1 디지털 콘텐츠 생성 도구

디지털 콘텐츠 생성 프로그램\(Digital content creation\) : 게임에 필요한 아트 자원들을 작업하는데 사용하는 툴

대게 특화된 자원을 만드는데 중점

게임 월드 제작 등에서는 자체적인 툴을 사용하거나, 범용적인 툴을 사용하는 경우도 있다.

작업 해내는데 멋들어질 필요는 없고, 좋은 게임을 만들기 위해 툴은 사용하기 쉬울수록 좋으며, 반드시 안정적으로 동작해야 한다.

### 1.7.2 자원 다듬기 파이프라인

DCC 에서 만든 데이터를 바로 사용할 수 없는 이유

* 게임 엔진에서 쓰기에 필요 이상으로 복잡하다. 극히 일부분의 정보만 있어도 된다.
* 데이터 파일 형식을 읽어들이는데 시간과 비용, 저작권이 걸리는 경우도 있다.

  접근성이 뛰어난 다른 포멧 아니면 다른 형태로 export 해야 한다.

  데이터를 export 해도 게임 엔진 내부에서는 좀 더 가공해야 한다.

  리소스를 모으거나 분리할 때 중간 과정에서 가공할 수 있다.

  각 플랫폼 별로 적합한 형태로 정렬해 묶는 과정을 추가로 거치게 할 수도 있다.

### 1.7.3 3D 모델과 메시 데이터

#### 1.7.3.1 브러시 기하 형상

평면 여러개로 이루어진 볼록 입체 다각형\(convex hull\) 모음.

* 빠르고 만들기 쉽다.
* 게임 디자이너가 쉽게 사용할 수 있다. 프로토타입을 만들기 위해 사용되는 경우도 있다.
* 충돌 볼륨 역할을 할 수도 있다.
* 복잡하게 만들기 힘들다.
* 관절 있거나 활동하는 물체 표현하기 힘들다.

#### 1.7.3.2 3D 모델\(메쉬\)

 Mesh : 삼각형과 정점으로 이뤄진 모양을 가진 형태.

 \(책에서는 형상 한 개인 경우는 '메쉬'로 하고 기타 데이터가 복합적으로 혼합된 객체를 '모델'이라고 칭함\)

 메시 만들때는 3D 모델링 프로그램을 이용하는 것이 보통.

 ZBrush 는 직관적인 방식으로 정교한 메시 만들고, 메시 해상도를 낮춰서 \(down convert\) 노말맵을 정교하게 보강

 DCC 툴에서 제작한 데이터는 export tool 을 써서 내보내게 되므로 필수적인 존재.

 게임에 바로 사용하기 적합하지 않을수 있어서 자신들만의 파일 포맷과 내보내기 도구로 제작한다.

### 1.7.4 뼈대 애니메이션 데이터

Skeletal mesh : 애니메이션 하기 위해 뼈대 구조에 연결되는 특수한 형태의 매시.

 각 정점마다 뼈대의 어느 관절\(joint\)들에 연결되는지를 나타내는 정보가 담겨 있다.

 뼈대 영향 받는 가중치도 함께 갖는것이 일반적.

* 메시
* 뼈대\(Skeletal\) 구조 \(관절 이름, 부모-자식 관계, 뼈대 생성 기본 포즈\)
* 뼈대 움직이는지 나타내는 애니메이션

 export 할때는 메시와 뼈대는 같은 파일로 함께 나오지만, 여러개의 메시가 같은 뼈대를 사용한다면 뼈대 정보를 분리해 다른 파일로 뽑아내는 게 좋다.

 여러 애니메이션을 묶어 한 파일로 뽑거나, 메시와 뼈대와 애니메이션을 한번에 모은 큰 파일을 사용하는 경우도 있다.

 Skeletal animation 데이터는 4\*3 행렬 모음으로 용량이 크기 때문에, 대부분 압축해서 저장한다.

### 1.7.5 오디오 데이터

 Sound Forge 같은 오디오 제작 툴로 만듦.

 모노/스테레오/5.1ch/7.1ch 다양한 멀티 채널

 wav, 플레이스테이션 ADPCM\(.vag, xvag\) 등의 형식들

 관리 편의성, 접근성, 스트리밍 기준 등에 묶어서 저장.

### 1.7.6 파티클 시스템 데이터



